## 트리

- 비선형 구조
  - 원소들 간에 1:n관계를 가지는 자료구조
  - 원소들 간에 계층 관계를 가지는 계층형 자료구조
  - 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무)모양의 구조

- 한 개 이상의 노드로 이루어진 유한집합이며 다음 조건을 만족한다

  - 노드 중 최상위 노드를 루트(root)라 한다.

  - 나머지 노드들은 n(>=0)개의 분리 집합 T1,...TN으로 분리될 수 있다

  - 아래의 그림에서 T1,...,TN은 각각 하나의 트리가 될 수 있으며(재귀적 정의) 루트의 부 트리(subtree)라 한다

    <img src="Tree.assets/image-20210827090707721.png" alt="image-20210827090707721" style="zoom: 50%;" />

- 용어정리
  - 잎 노드 = 맨 끝에 다다른 노드
  - 노드(node) - 트리의 원소
    - 트리 T의 노드 - A, B, C, D, E, F, G, H, I, J, K
  - 간선(edge) - 노드를 연결하는 선. 노드와 자식 노드를 연결
  - 루트 노트(root node) - 트리의 시작노드 (탐색의 시작 위치가 아니다)
    - 트리T의 루트노드 : A
  - 형제 노드 (sibling node) - 같은 부모 노드의 자식 노드들
    - B, C, D는 형제 노드
  - 조상 노드 - 간선을 따라 루트노드까지 이르는 경로에 있는 모든 노드들
    - K의 조상 노드  : F, B, A
  - 서브 트리(subtree) - 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
  - 자손 노드 - 서브 트리에 있는 하위 레벨의 노드들
    - B의 자손노드 : E, F, K
  - 차수(degree)
    - 노드의 차수 : 노드에 연결된 자식 노드의 수
      - B의 차수 = 2, C의 차수 = 1
    - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
      - 트리 T의 차수 = 3 (자식이 3인 경우)
    - 단말 노드(리프 노드) : 차수가 0인 노드, 자식 노드가 없는 노드
  - 높이
    - 노드의 높이 : 루트에서 노드에 이르는 간선의 수, 노드의 레벨
      - B의 높이 = 1, F의 높이 = 2
    - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값(최대 레벨)
      - 트리 T의 높이 = 3



##### * 이진 트리

- 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리

- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리

  - 왼쪽 자식 노드(left child node)
  - 오른쪽 자식 노드(right child node)

- 특성

  - 레벨 i에서의 노드의 최대 개수는 2^i개
  - 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h+1 개 (높이가 간선이 기준이므로), 최대개수는 2^(h+1)-1

  <img src="Tree.assets/image-20210827092153507.png" alt="image-20210827092153507" style="zoom: 50%;" />

##### 포화 이진 트리(Full Binary Tree)

- 모든 레벨에 노드가 포화상태로 차 있는 이진 트리
- 높이가 h일 때, 최대의 노드 개수인 2^h-1의 노드를 가진 이진 트리

- 루트를 1번으로하여 2^h-1까지 정해진 위치에 대한 노드 번호를 가짐

  - 왼쪽에서 오른쪽으로, 꽉 찰시 아래로 넘어가 번호를 부여

  ![image-20210827092828198](Tree.assets/image-20210827092828198.png)

##### 완전 이진 트리(Complete Binary Tree)

- 높이가 h이고 노드 수가 n개일 때(h+1 <= n < 2^(h+1)-1), 포화 이진 트리의 규칙대로 번호를 부여했을 때 노드 번호 1번부터 n번까지 빈 자리가 없는 이진트리

  - ex) 노드가 10개인 완전 이진 트리

    ![image-20210827093157796](Tree.assets/image-20210827093157796.png)

##### 편향 이진트리(Skewed Binary Tree)

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

  - 한 쪽으로 치우쳐진 트리

  - 왼쪽 편향 이진 트리

    ![image-20210827093306172](Tree.assets/image-20210827093306172.png)

  - 오른쪽 편향 이진트리

    ![image-20210827093341558](Tree.assets/image-20210827093341558.png)



##### 이진트리의 순회(trabersal)

- 트리의 각 노드를 중복되지 않게 전부 방문(visit)하는 것을 말한다
  - 트리는 비 선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없다

- 순회(traversal) : 트리의 노드들을 체계적으로 방문하는 방법

- 서브트리에 대해 순회를 시작하면 서브트리 안에서만 순회한다.(서브 트리 밖의 정점은 건들지 않는다) 

- 3가지 기본 순회방법

  - 전위순회(preoder traversal) : VLR
    - 부모노드 방문 후, 자식노드를 좌우 순서로 방문(방문한 정점에 대해 할 일)
  - 중위순회(inorder traversal) : LVR
    - 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문
  - 후위순회(postorder traversal) : LRV
    - 자식노드를 좌우 순서로 방문한 후, 부모노드로 방문

  ![image-20210827093845669](Tree.assets/image-20210827093845669.png)

- 전위 순회

  1. 현재 노드 n을 방문하여 처리한다 -> V
  2. 현재 노드 n의 왼쪽 서브트리로 이동 -> L
  3. 현재 노드 n의 오른쪽 서브트리로 이동 -> R

  - 알고리즘

    ```python
    def preorder_traverse(T): #전위순회
        if T: # T is not None
            visit(T) # print(T.item), 방문했을 때 할 일
            preorder_traverse(T.left) # 왼쪽자식
            preorder_traverse(T.right) # 오른쪽 자식
    ```

    ![image-20210827095112263](Tree.assets/image-20210827095112263.png)

- 중위 순회

  1. 현재 노드 n의 왼쪽 서브트리로 이동 -> L
  2. 현재 노드 n을 방문하여 처리한다 -> V
  3. 현재 노드 n의 오른쪽 서브트리로 이동 -> R

  - 알고리즘

    ```python
    def inorder_traverse(T): # 중위순회
        if T: # T is not None
            inorder_traverse(T.left) # 왼쪽자식
            visit(T) # print(T.item), 방문했을 때 할 일
            inorder_traverse(T.right) # 오른쪽 자식
    ```

    ![image-20210827100045268](Tree.assets/image-20210827100045268.png)

- 후위 순회

  1. 현재 노드 n의 왼쪽 서브트리로 이동 -> L
  2. 현재 노드 n의 오른쪽 서브트리로 이동 -> R
  3. 현재 노드 n을 방문하여 처리한다 -> V

  - 알고리즘

    ```python
    def postorder_traverse(T): # 후위순회
        if T: # T is not None
            postorder_traverse(T.left) # 왼쪽자식
            postorder_traverse(T.right) # 오른쪽 자식
            visit(T) # print(T.item), 방문했을 때 할 일
    ```

    ![image-20210827100208337](Tree.assets/image-20210827100208337.png)

- 전위, 중위, 후위 생각해보기

  ![image-20210827104302929](Tree.assets/image-20210827104302929.png)

  ```
  전위 : ABDHIEJCFKGLM
  중위 : 
  후위 : 



##### * 배열을 이용한 이진트리의 표현(저장 방법)

- 선형구조인 배열(리스트)를 가지고 트리구조를 어떻게 구현할 것인가?

- 이진 트리에 각 노드 번호를 다음과 같이 부여
  - 루트의 번호를 1로 함
    - 트리의 특성에따라 루트의 번호가 달라질 수도 있다는것을 주의!
  - 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n부터 2^(n+1)-1까지 번호를 차례로 부여

![image-20210827104512806](Tree.assets/image-20210827104512806.png)

- idex(= node번호)를 이용해 표현해보기

  ```
  노드 번호가 i인 노드의 부모 노드 번호는? i//2
  노드 번호가 i인 노드의 왼쪽 자식 노드 번호? 2*i
  노드 번호가 i인 노드의 오른쪽 자식 노드 번호? 2*i + 1
  레벨 n의 노드 번호 시작 번호는? 2^n
  ```

  ![image-20210827105235299](Tree.assets/image-20210827105235299.png)

  - 높이가 h인 이진트리를 위한 배열의 크기

    - 2^(h+1) - 1

      ![image-20210827110604248](Tree.assets/image-20210827110604248.png)

- 배열을 이용한 이진 트리의 표현의 단점

  - 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생

    - 편향 이진트리를 위의 방법으로 표현해보기 (비효율적)

    ![image-20210827110304230](Tree.assets/image-20210827110304230.png)

  - 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의 크기 변경 어려워 비효율적

- 문제로 접근

  ```
  첫 줄에는 트리의 정점의 총 수 V가 주어진다. 그 다음 줄에는 V-1개 간선이 나열된다. 간선은 그것을 이루는 두 정점으로 표기된다. 간선은 항상 "부모 자식"순서로 표기된다. 아래 예에서 두 번째 줄 처음 1과 2는 정점 1과 2를 잇는 간선을 의미하며 1이 부모, 2가 자식을 의미한다. 간선은 부모 정점 번호가 작은 것부터 나열되고, 부모 정점이 동일하다면 자식 정점 번호가 작은 것부터 나열된다.
  ```

  ```python
  def pre_order(n):
      if n: # 유효한 정점이면
  		print(n, end=' ')
          pre_order(left[n]) # n의 왼쪽자식으로 이동
          pre_order(right[n])
          
  V = int(input()) # node 개수
  edge = list(map(int, input().split())) # 부모-자식
  E = V - 1 # V개의 정점이 있는 트리의 간선 수
  left = [0] * (V+1)
  right = [0] * (V+1)
  for i in range(E):
      p, c = edge[i*2], edge[i*2+1]
      if left[p] == 0: # p의 왼쪽 자식이 없으면
          left[p] = c
      else: # 왼쪽자식이 있으면 오른쪽자식으로 저장
          right[p] = c
  pre_order(1)
  # 입력 :
  6
  1 2 1 3 2 4 3 5 3 6
  # 출력결과 : 1 2 4 3 5 6

##### * 연결리스트를 이용한 트리의 표현(저장 방법)

- 배열을 이용한 이진 트리 표현의 단점을 보완하기 위해 연결리스트를 이용하여 트리를 표현

- 연결 자료구조를 이용한 이진트리의 표현

  - 이진 트리의 모든 노드는 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결 리스트 노드를 사용하여 구현

    ![image-20210827110907331](Tree.assets/image-20210827110907331.png)

- 완전 이진 트리의 연결 리스트 표현

  ![image-20210827110934852](Tree.assets/image-20210827110934852.png)

