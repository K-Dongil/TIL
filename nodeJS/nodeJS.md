## NodeJS

- 크롬 V8 자바스크립트 엔진으로 Build된 자바스크립트를 런타임(실행)하는 것

  - 런타임: 특정 언어로 만든 프로그램들을 실행할 수 있게 해주는 가상 머신(크롬의 V8 엔진 사용)의 상태

- 내부 : V8과 libuv를 내부적으로 포함한다

  - V8 엔진 : 오픈 소스 자바스크립트 에진 => 속도 문제 개선
  - libuv: 노드의 특성인 이벤트 기반, 논블로킹 I/O 모델을 구현한 라이브러리

  ![image-20220423202221191](nodeJS.assets/image-20220423202221191.png)



##### * 자바스크립트를 왜 Node가 실행해야하는 것일까?

- Node : 자바스크립트로 만든 프로그램을 실행할 수 있게 해준다

- 브라우저가  html을 읽으면서 script source를 같이 읽었다
  - html이 없으면 script를 읽을 수 없다
  - html에 종속되어 있었다
- NodeJs를 설치하면 html상관없이 V8 자바스크립트 엔진으로 script source를 해석해준다
  - Node가 html에대한 종속을 벗어나게 해주었다
  - Node가 자바스크립트의 역할을 확장시켜준다
- Node는 서버가 아니다
  - 자바스크립트로 서버코드를짜면 서버가 되는것
    - 서버 실행을 위해 필요한 http/https/http2 모듈을 제공
  - 서버의 역할도 수행할 수 있는 자바스크립트 런타임
- Node 이전에도 자바스크립트로 런타임을 만들기 위한 많은 시도가 있었으나 엔진 속도 문제로 실패



##### * 이벤트 기반

- 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식

  - ex) 클릭, 네트워크 요청, 타이머 등
  - `event listener` : 이벤트를 등록하는 함수
  - `Callback Function` : 이벤트가 발생했을 때 실행될 함수 

  ![image-20220423202502783](nodeJS.assets/image-20220423202502783.png)



##### * 논블로킹 I/O

- 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 나중에 오래 걸리는 함수를 실행

  - 논 블로킹 방식 하에서 일부 코드는 백그라운드에서 병렬로 실행됨
  - 일부 코드 :  I/O 작업(파일 시스템 접근, 네트워크 요청), 압축, 암호화 등
  - 나머지 코드는 블로킹 방식으로 실행됨

  ![image-20220423203319356](nodeJS.assets/image-20220423203319356.png)



## Server

- 다른 컴퓨터에서 연결이 가능하도록 **대기 상태**로 상시 실행중인 프로그램
  - ex) 영업중인 식당
    - 손님이 올 수 있도록 식당을 열고 대기중인 상태
    - 손님이 오면 식당 메뉴/ 정책에 따라 서비스 제공

1. Web Server (aka. HTTP server)

   - Client가 요청을 보내고 Server가 응답을 보낸다
     - 실시간 상호작용 X (요청&응답)
     - Client와 Server간 질의 /응답 형태
     - 드물게 정보를 요청/갱신
     - 실시간 Interaction 필요X
     - Server에서 Client에게 먼저 접근할 일X
   - Client가 떠나면 Server에서는 Client의 상태를 당분간 잊고 지낸다(Stateless)
   - 웹 서비스를 만드는 데 사용
     - 구글, 아마존, 네이버 등등
     - 처음부터 만드는 경우는 거의 없고 프레임워크를 하나 골라서 사용
       - ASP.NET, Spring, NodeJS, Django, Flask, PHP
   - ex) 테이크아웃 포장 전문 식당

2. Game server(aka. TCP server, Binary Server, Stateful Server)

   - Client와 Server간 실시간 상호작용

     - 요청/갱신 횟수가 많다
     - 실시간 Interaction필요
     - Server가 언제라도 Client에게 접근 가능해야한다
     - Client가 Game에 접속해있을 때, Server가 Client의 상태를 보며 서비스 제공한다(Stateful)

   - Game Server도 Web Server를 이용한다

     - ex) 인증 & 로그인 -> Web Server이용 후 GameServer로 넘어온다

   - 최적의 프레임워크 & 장르에 따라 요구사항이 다르다

     | 고려할 대상              | 의미                      |
     | ------------------------ | ------------------------- |
     | 최대 동시 접속자         |                           |
     | Thread 개수 & 모델       |                           |
     | 게임 로직                | Client의 행동에 따른 운영 |
     | 네트워크                 | Client와 Server간 소통    |
     | DB                       | 데이터 처리               |
     | 게임장르 및 채널링       |                           |
     | 네트워크 모델            |                           |
     | 반응성(FPS, MMORPG, ...) |                           |

   - ex) 일반 식당

##### * 프로그램

- 실행 가능한 명령어의 집합



##### * 프로세스 & 스레드

- 프로세스 : 운영체제에서 할당하는 작업의 단위, 프로세스 간 자원 공유X

  - 기본적으로 프로그램 하나 띄울 때 프로세스가 한개 이상 뜬다
  - ex) Chrome

- 스레드 : 프로세스 내에서 실행되는 작업의 단위, 부모 프로세스 자원 공유

  - ex) Chrome의 Tab

- Node Process는 멀티 스레드이지만 직접 다룰 수 있는 스레드는 하나이기 때문에 싱글 스레드라고 표현

  - Node가 Single Thread였다면 코드가 동시에 돌아가는 것이 불가능했을 것이다

- Node는 주로 멀티 스레드 대신 멀티 프로세스 활용

- 14버전부터 멀티 스레드 사용 가능

  ![image-20220423203645007](nodeJS.assets/image-20220423203645007.png)



##### * 프로세스

- 컴퓨터에서 실행되고 있는 프로그램
- 메모리에 적재되어 실행되고 있는 프로그램
  - 실제 실행중인 프로그램을 일컫는다(동적이라고 표현하기도 함)
- 프로세스마다 최소 1개의 스레드 소유(메인 스레드)
- 각 프로세스는 별도의 주소 공간에서 실행되며, 다른 프로세스의 변수나 자료구조에 접근이 불가
  - 다른 프로세스의 자원에 접근하기 위해서는 IPC를 사용
- 프로세스는 각각 독립된 메모리 영역(Code(text), Data, Heap, Stack)을 할당받는다
  - Code: 프로그램의 실제 코드 저장
  - Data: 프로세스 실행 시 정의된 전역변수와 static변수
  - Heap: 프로세스 런타임 중 동적으로 할당되는 변수들 저장(함수 내에서 할당되는 변수 등)
  - Stack: 함수에서 다른 함수를 실행하는 등의 서브루틴들의 정보 저장



##### * 스레드

- 프로세스 내에서 실행되는 여러 흐름의 실행 단위

- 스레드는 CPU가 실행시켜야 동작한다

  - 1개의 CPU는 1개의 스레드를 실행시킬 수 있다

  - 1개의 CPU가 각 프로그램을 왔다갔다 반복하면서 스레드를 실행시킨다

    - 우리 눈에는 여러개의 프로그램이 동시에 돌아가는 것처럼 보인다
    - CPU가 왔다갔다하면서 스레드를 동작시키는 과정자체가 무겁고 힘든과정

    <img src="nodeJS.assets/image-20220419154216566.png" alt="image-20220419154216566" style="zoom:50%;" />

- 기아현상 : CPU가 한 쪽 프로그램에 몰려있으면 다른 프로그램은 실행이 원활하지 않다

- 모든 스레드는 Heap영역과 데이터 영역을 공유하지만, 스택영역은 공유하지 않는다

  - 스택을 공유하지 않는 이유
    - 스택은 함수 호출 시 전달되는 인자, 작업 후 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간
    - 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것
    - 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당
  - PC 레지스터를 공유하지 않는 이유
    - PC값은 스레드가 명령어의 어디까지 수행하였는지를 나타내게 된다
    - 스레드는 CPU를 할당받았다가 스케쥴러에 의해 다시 선점, 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억해야 한다.
  - Heap, data영역을 공유하기 때문에 IPC없이도 스레드간 통신가능
  - code 영역을 공유하기 때문에 프로세스 내부 스레드들은 프로세스가 가지고 있는 함수 호출가능

  <img src="nodeJS.assets/image-20220419165831975.png" alt="image-20220419165831975" style="zoom:50%;" />





##### * 싱글 스레드

- 주어진 일을 하나밖에 처리하지 못한다

  - 블로킹이 발생하는 경우 나머지 작업은 모두 대기해야 함 -> 비효율

- 프로그램 1개에 1개의 스레드로 구성하여 작업을 처리

- 싱글 스레드 모델은 에러를 처리하지 못하는 경우 멈춘다

  - 프로그래밍 난이도 쉽고, CPU, 메모리 자원 적게 사용

- ex) 주방에 비유 (점원 : 스레드, 주문 : 요청, 서빙 : 응답)

  ![image-20220423204039074](nodeJS.assets/image-20220423204039074.png)



##### * 멀티스레드

- 프로그램에 여러개의 스레드로 구성하여 작업을 처리

- 에러 발생 시 새로운 스레드를 생성하여 극복

- 장점

  - 스레드들은 각자의 stack, 레지스터 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다
  - 스레드간 데이터를 주고 받는 것이 간단해지고 시스템 자원소모가 감소
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소하여 자원의 효율적 관리 가능

- 단점

  - 하나의 스레드가 데이터 공간 훼손 시, 모든 스레드가 작동 불가 상태
    - 공유하는 메모리를 소유하기 때문이다
  - 새로운 스레드 생성이나 놀고 있는 스레드 처리에 비용 발생
  - 프로그래밍 난이도 어려움
  - 스레드 수만큼 자원을 많이 사용

- ex) 주방에 비유 (점원 : 스레드, 주문 : 요청, 서빙 : 응답)

  ![image-20220423205032627](nodeJS.assets/image-20220423205032627.png)



##### * NodeJs에서의 싱글 스레드

- 멀티 프로세싱
  - 스레드가 하나인 노드 프로세스를 여러개가 존재
    - 요청을 각 프로세스에 분산시킨다

- 논 블로킹 모델을 채택하여 일부 코드(I/O)를 백그라운드(다른 프로세스)에서 실행 가능

  - 요청을 먼저 받고, 완료될 때 응답함
  - I/O관련 코드가 아닌 경우 싱글 스레드, 블로킹 모델과 같아짐

  ![image-20220423205227450](nodeJS.assets/image-20220423205227450.png)